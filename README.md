# Constructors and Destructors in C++

## Name: Maitraiyee Vashistha
## PRN: 24070123057
## Division: ENTC-A3
## Title: Constructors and Deconstructors in C + + 
---

## Aim :
*To study and apply Constructors and Deconstructors in C++*

-----
## Introduction

In object-oriented programming (OOP), **constructors** and **destructors** are special member functions that manage the creation and destruction of objects. They are crucial in ensuring that objects are initialized properly when they are created, and resources are released appropriately when they are destroyed.

- **Constructors** initialize objects when they are created.
- **Destructors** clean up resources when objects go out of scope or are explicitly deleted.

This document covers the theory behind both **constructors** and **destructors**, their types, and their role in resource management.

---

## What is a Constructor?

A **constructor** is a special function in a class that is automatically called when an object of that class is created. It is used to initialize the object's data members and perform any setup required for the object.

### Characteristics of Constructors

- **Same name as the class.**
- **No return type**, not even `void`.
- **Automatically invoked** when an object is instantiated.
- Can be **overloaded**, meaning multiple constructors can exist in the same class, each with different parameters.

### Types of Constructors

1. **Default Constructor**
   - A constructor that takes **no parameters** or all parameters have default values.
   - Provides a default way to initialize an object.
   - Automatically generated by the compiler if no other constructors are defined.

2. **Parameterized Constructor**
   - A constructor that takes **parameters** to initialize an object with specific values.
   - Allows different objects to be initialized with different values at the time of creation.

3. **Copy Constructor**
   - A constructor that creates a **new object as a copy of an existing object** of the same class.
   - Used for making copies of objects, typically in the case of passing objects by value, returning objects from functions, or assigning objects to each other.
   - When a class involves resource management (e.g., dynamic memory), it’s important to define a custom copy constructor to avoid issues like double freeing memory or shallow copying.
   
---

## What is a Destructor?

A **destructor** is a special member function that is called automatically when an object goes out of scope, or is explicitly deleted (in the case of dynamically allocated objects). Destructors are responsible for **cleaning up** resources used by the object, such as memory, file handles, and other system resources.

### Characteristics of Destructors

- **Same name as the class**, but prefixed with a tilde (`~`).
- **No return type** and **no parameters**.
- **Automatically called** when an object is destroyed (goes out of scope or is deleted).
- A class can have **only one destructor** because it doesn't take parameters or support overloading.

### Purpose of Destructors

- **Release resources**: Destructors clean up memory and other resources that were allocated during the lifetime of an object.
- **Prevent memory leaks**: For classes that manage dynamic memory (using `new`), destructors are responsible for calling `delete` to free that memory when the object is no longer needed.
- **Ensure cleanup**: Even when exceptions are thrown or control flow exits prematurely, destructors ensure that any necessary cleanup happens automatically.

### Destructor and Resource Management

If a class allocates resources dynamically (e.g., memory using `new`), the destructor should release those resources (e.g., using `delete` or `delete[]`). Failure to do so may lead to **memory leaks** or other resource issues.

---

## Constructor and Destructor Pairing

In classes that manage resources, it's critical to **pair** constructors and destructors properly:

- A **constructor** allocates resources and initializes the object.
- A **destructor** releases those resources when the object goes out of scope or is deleted.

This pairing ensures that resources are not leaked and that an object’s lifetime is properly managed.

### Example Use Cases for Destructors

- **File handling**: If a class opens a file, the destructor can ensure the file is closed when the object is destroyed.
- **Dynamic memory management**: If a class allocates memory using `new`, the destructor can release that memory using `delete`.
- **Network connections**: If a class maintains a network connection, the destructor can close the connection before the object is destroyed.

---

## Constructor Initialization List

- An **initialization list** is an efficient way to initialize class members when an object is created.
- It’s typically used to initialize **const members**, **reference members**, or **base classes** in derived classes.
- Initialization lists ensure that class members are initialized before the constructor body runs.

---

## Summary Table

| Constructor/Destructor Type | Purpose                                    | When Called                                    | Key Characteristics                        |
|-----------------------------|--------------------------------------------|------------------------------------------------|--------------------------------------------|
| **Default Constructor**      | Initializes object with default values     | When object is created without arguments       | No parameters, either user-defined or compiler-generated |
| **Parameterized Constructor**| Initializes object with given values       | When object is created with arguments          | Accepts parameters to customize initialization            |
| **Copy Constructor**         | Initializes object as copy of another      | When an object is copied                       | Creates a new object by copying an existing one            |
| **Destructor**               | Releases resources and cleans up           | When object goes out of scope or is deleted    | Automatically invoked when an object is destroyed          |

---

## Summary of Programs

### Program 1. Default Constructor defined inside a class

1. **Start**
2. Define a class named `student` with the following **private data members**:
   - `rollno` (double)
   - `name` (character array of size 50)
   - `fee` (double)
3. Declare a **public constructor** for the class `student` that performs the following:
   - Display: `"Enter the RollNo.: "`
   - Read and store user input in `rollno`
   - Display: `"Enter the Name: "`
   - Read and store user input in `name`
   - Display: `"Enter the Fee: "`
   - Read and store user input in `fee`
4. In the `main()` function:
   - Create an object `s` of class `student`
   - Constructor is automatically called, prompting the user for input
5. **End**


### Program 2. Default Constructor Outside a class

1. **Start**
2. Define a class named `Date` with private data members:
   - `date` (integer)
   - `month` (integer)
   - `year` (integer)
3. Declare a public **constructor** that:
   - Prompts the user to enter the day, month, and year.
   - Reads the values and stores them in the respective data members.
4. Define a public member function `display()` that:
   - Displays the date in the format `DD/MM/YYYY`.
5. In the `main()` function:
   - Create an object `d` of class `Date`.
   - Call `d.display()` to show the entered date.
6. **End**


### Program 3. Parameterized Constructor

1. **Start**
2. Define a class `construct` with private data members:
   - `a` (integer)
   - `b` (integer)
3. Define a public parameterized constructor that:
   - Accepts two integer parameters `m` and `n`
   - Initializes `a` with `m` and `b` with `n`
4. Define a public member function `putdata()` that:
   - Prints the values of `a` and `b`
5. In the `main()` function:
   - Create an object `c` of class `construct`, passing `1000` and `25` as arguments
   - Call `c.putdata()` to display the values of `a` and `b`
6. **End**


### Program 4. Copy Constructor Example - 1

1. **Start**
2. Define a class `student` with private data members:
   - `age` (integer)
   - `name` (string)
3. Define a **parameterized constructor** that:
   - Takes `string s` (name) and `int a` (age) as parameters
   - Initializes the data members `name` and `age`
4. Define a **copy constructor** that:
   - Accepts a reference to another `student` object
   - Copies the `name` and `age` from the existing object
   - Prints messages indicating it was called
5. Define a member function `display()` to:
   - Print the student's name and age
6. In `main()` function:
   - Create a student object `s1` with name `"Maitraiyee"` and age `18`
   - Create another student `s2` by copying `s1` (invokes copy constructor)
   - Call `display()` on both `s1` and `s2` to show their data
7. **End**


### Program 5. Copy Constructor Example - 2

1. **Start**
2. Define a class `Car` with private data members:
   - `Price` (int)
   - `name` (string)
   - `id` (int)
3. Create a **parameterized constructor**:
   - Takes parameters: name (`string`), price (`int`), and id (`int`)
   - Initializes the data members
4. Create a **copy constructor**:
   - Accepts a reference to another `Car` object
   - Copies values from the original object's members
   - Outputs a message to indicate the copy constructor was invoked
5. Define a member function `display()`:
   - Prints car details: name, price, and id
6. In `main()`:
   - Create object `c1` using the parameterized constructor
   - Create object `c2` by copying `c1` (copy constructor is called)
   - Call `display()` on both objects
7. **End**


### Program 6. Destructors Example - 1

1. **Start**
2. Declare a **global variable** `count = 0` to track object creation and destruction.
3. Define a class `destruct` with:
   - A **constructor** that:
     - Increments the global `count`
     - Prints the number of objects created
   - A **destructor** that:
     - Decrements the global `count`
     - Prints the number of objects destroyed
4. In `main()`:
   - Create four objects: `aa`, `bb`, `cc`, and `dd`
   - The constructor will be called 4 times, increasing and displaying `count`
5. When `main()` ends, destructors are called automatically in **reverse order** of creation:
   - The count is decremented with each destructor call
   - Destruction messages are printed accordingly
6. **End**


### Program 7. Destructors Example - 2

1. **Start**
2. Define a class `Date` with public data members:
   - `d = 26` (day)
   - `m = 8` (month)
   - `y = 2023` (year)
3. Define a **destructor** that:
   - Prints `"Destructor Called !"` when an object is destroyed
4. In `main()`:
   - Create four `Date` objects: `d1`, `d2`, `d3`, and `d4` (all are local to `main()`)
   - Create a `for` loop that runs 4 times
     - Inside the loop, a new `Date` object `d1` is declared in each iteration
     - These objects go out of scope **at the end of each iteration**, so their destructors are called immediately
5. After the loop ends, the four initial objects (`d1`–`d4`) go out of scope when `main()` ends
6. **End**
---
## Conclusion

Constructors and destructors form the backbone of robust and safe C++ programming by automating the critical processes of object initialization and cleanup. Proper use of constructors guarantees that objects start in a valid state, while well-defined destructors ensure that resources like memory, files, and connections are released correctly, preventing leaks and other runtime issues.

Mastering constructors and destructors is essential for writing clean, efficient, and reliable code, especially in complex systems that manage resources dynamically. With a solid understanding of these concepts, developers can leverage C++’s powerful object-oriented features to create maintainable and high-performance applications.

---


